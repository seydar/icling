<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- FILE:      SyntaxTree.html
     PURPOSE:   describe the syntax tree
     COPYRIGHT: W.M.McKeeman 2007.  You may do anything you like with 
     this file except remove or modify this copyright.
     MODS:      McKeeman - 2007.07.06 - original
  -->

<HTML>

<HEAD>
<TITLE>
  A Short Course in Compilers -- Syntax Tree
</TITLE>
</HEAD>

<BODY BGCOLOR="#FFF0D0">

<!-- the following table head provides margins and textbook-like appearance -->
<TABLE>
<TR><TD></TD></TR>
<TR><TD WIDTH="50"></TD><TD WIDTH="600">

<P ALIGN="RIGHT">
<SMALL>
<EM>File</EM> SyntaxTree.html&nbsp;&nbsp;&nbsp;  
<EM>Author</EM> McKeeman&nbsp;&nbsp;&nbsp;  
<EM>Copyright</EM> &copy; 2007&nbsp;&nbsp;&nbsp;  
<A HREF="Index.html">index</A>
</SMALL>
</P>
<!-- ----------------------------------------------------------------- -->

<CENTER>
<H3>Syntax Tree, Abstract Syntax Tree</H3>
</CENTER>

<H4>Syntax Tree</H4>

<P>
First review context-free grammar 
<A HREF="ContextFreeGrammar.pdf">theory</A>.
</P>

<P>The syntax tree for an X program is completely determined by the
<A HREF="Xcfg.html">X Cfg</A>.
The syntax tree is systematically generated by <B>Tree.m</B> 
from the <B>shift/reduce</B> sequence made by the parser.  
Each shift causes a token to be stacked.
Each reduce represents the application of a Cfg rule. Suppose the Cfg 
rule has <B>w</B> elements on the r.h.s.  
The reduce action pops <B>w</B> elements off the stack; 
puts them into the tree as a node, 
then pushes the node onto the stack.  
The elements that were
popped are the descendents of the newly-stacked node.
Here is a <A HREF="SyntaxTree.pdf">worked example</A>.
</P>
<P>
The tree consists of internal nodes and peripheral leaves.  
All of the significant (non-white) tokens from the input are the leaves 
of the tree.
The xcom tree is not designed to be transformed (<B>read-only</B> use).
</P>

<H4>Tree Walking</H4>
<P>
The syntax tree is accessed by tree walking methods of the Tree object.
Suppose T is a Tree object and n is a node.
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3">
<TR>
  <TD ALIGN="CENTER" WIDTH="100"><EM>Tree method call</EM></TD>
  <TD ALIGN="CENTER" WIDTH="300"><EM>method description</EM></TD>
</TR>
<TR>
  <TD>n&nbsp;=&nbsp;T.getRoot()</TD>   
  <TD>the unique node for X CFG phrase <B>program</B></TD>
</TR>
<TR>
  <TD>r&nbsp;=&nbsp;T.getRule(n)</TD>   
  <TD>The name of node n</TD>
</TR>
<TR>
  <TD>p&nbsp;=&nbsp;T.getPat(n)</TD>    <TD>The Node/Leaf pattern of node n</TD>
</TR>
<TR>
  <TD>w&nbsp;=&nbsp;T.getWidth(n)</TD>  <TD>The number of kids of node n</TD>
</TR>
<TR>
  <TD>n&nbsp;=&nbsp;T.getKid(n, i)</TD>   <TD>The i<SUP>th</SUP> subnode of node n</TD>
</TR>
<TR>
  <TD>t&nbsp;=&nbsp;T.getLeaf(n)</TD>   <TD>The token associated with the (leaf) node n</TD>
</TR>
</TABLE>
The whole tree is accessible, in any order, from the root. 
Method 
<BIG><PRE>
        n2 = getKid(n1,i) 
</PRE></BIG>
moves leafward from node n1 to i<SUP>th</SUP> subnode n2.  
Returning from getKid moves rootward.
</P>

<H4>Nodes and Leaves</H4>
<P>
Method getRule(n) returns the name of the Cfg phrase for node n.
Which subnodes are internal and which are leaves is obvious from the Cfg.
If the phrase name for some node n is a leaf (e.g. id),
it is an error to call getKid(n,i) on it.
Instead, getLeaf(n) returns the <A HREF="Lexing.html">token</A>.
</P>
<P>
The method getPat(n) is redundant in that knowing the Cfg allows the
correct choice to be made between getKid(n) and getLeaf(n).  
On the other hand, it is sometimes convenient to walk a tree without
reference to the grammar (for example, a general tree dumper).  
The Tree fields
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3">
<TR><TD>T.NONE</TD></TR>
<TR><TD>T.NODE</TD></TR>
<TR><TD>T.LEAF</TD></TR>
<TR><TD>T.OPAQ</TD></TR>
</TABLE>
can be used to decode the getPat(n) value.  The value NONE terminates
a pattern.
The value OPAQ never appears in xcom; it is intended for extensions
when the corresponding node index points to neither an internal node nor
to a leaf -- a so-called tree decoration.
</P>

<H4>Abstract Syntax Tree (AST)</H4>
<A NAME="chains">
<P>
It is in the nature of programming language syntax trees that much
of the data is not needed.  In particular, the long chains of reduce
actions
</P>
<P ALIGN="CENTER">
expr<-disjunction<-conjunction<-negation<-relation<-sum<-term<-factor
</P>
<P>
required to expression operator precedence all show up in the tree
and must be walked over to get to the significant stuff.
Also, most of the leaves (such as '+' or parens) are never examined.
An abstract syntax tree is one with these nodes snipped out.
Such a tree takes less space and time but it takes an additional 
set of specifications and must be maintained each time the Cfg changes.
The <A HREF="SyntaxTree.pdf">worked example</A> shows the results.
</P>

<P>
In xcom one can choose the full syntax tree with flag<BR>
    <BIG><TT> >> xcom -noAST</TT></BIG> <EM>other args</EM>.
</P>

<H4>Writable Trees</H4>
<P>
It is common, in production compilers,
to find writable abstract syntax trees.
Once semantic information is gathered about some node, 
the information is written into the node.
In xcom this is never done, 
but rather the information is kept in the <B>locals of the tree walker</B>
or in an <B>auxiliary data structure</B> (for instance, the symbol table).
The node type OPAQ mentioned above could be used to flag a writable
node.  
</P>

<!-- ----------------------------------------------------------------- -->
<!-- the following table end provides margins and textbook-like appearance -->
</TD><TD WIDTH="50"></TD></TR>
</TABLE>

</BODY>
</HTML>
